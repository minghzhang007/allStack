装饰者模式：
角色：
Component:组件对象的抽象接口，可以给这些对象动态的增加职责/功能。
ConcreteComponent:具体的组件的对象，实现组件对象的接口，是被装饰器装饰的原始对象，即可以给这个对象动态的添加职责。
Decorator:所有装饰器的抽象父类，实现了组件对象的接口，并且持有一个组件对象（被装饰的对象）。
ConcreteDecorator:具体的装饰器，具体实现向装饰对象添加功能。

I/O
InputStream 相当于装饰者模式的Component
FileInputStream,ByteArrayInputStream,ObjectInputStream这些对象直接继承了InputStream,相当于装饰者模式中的ConcreteComponent
FilterInputStream 继承了InputStream,并且持有了一个InputStream ,相当于装饰者模式中的Decorator
BufferedInputStream,PushbackInputStream,LineNumberInputStream,DataInputStream继承了FilterInputStream,相当于装饰者模式中的ConcreteDecorator

优点：
1.比继承更灵活
    从为对象添加功能的角度来看，装饰者模式比继承更为灵活。继承是静态的，一旦继承，所有的子类都有一样的功能。装饰者模式采用把功能分离到每个装饰器当中，
    通过对象组合的方式，在运行时动态的组合功能，被装饰对象最终由哪些功能，是由运行时动态组合的功能决定的。
2.复用功能更容易
    装饰模式把一系列复杂的功能分散到每个装饰器中，一般情况下每个装饰器只实现一个功能，使得实现装饰器变得简单，有利于装饰器功能的复用，可以给一个对象添加
    多个装饰器，也可以把一个装饰器装饰多个对象，从而实现复用装饰器的功能。
3.简化高层定义
    装饰者模式可以通过组合装饰器的方式，为对象添加任意多的功能；因此在高层定义的时候，不必把所有的功能都定义处理，只需要定义最基本的就可以了，在需要的时候可以
    通过组合装饰器的方式来完成所需的功能。

缺点：会产生较多的细粒度的对象
    装饰模式把一系列复杂的功能分散到每个装饰器中，一般情况下每个装饰器只实现一个功能，这样会产生很多细粒度的对象，并且功能越复杂，细粒度对象越多。

装饰者模式：
 本质：动态组合

使用场合：
 如果需要再不影响其他对象的情况下，以动态、透明的方式给对象增加职责，可以使用装饰者模式。
 如果不适合使用子类进行扩展的时候，可以考虑使用装饰者模式。装饰者模式使用的是对象组合的方式。 不适合子类扩展：比如扩展功能需要的子类太多，造成子类数量呈爆炸性增长。

























